
# WebServer

练手写的http服务器，慢慢完善修改。

## 一. 编译环境

系统：Ubuntu20.04

工具链：g++ 9.4.0；gdb 9.2；make 4.2.1；cmake 3.16.3

第三方依赖库：

1. [yaml-cpp](https://github.com/jbeder/yaml-cpp)

2. boost 1.71

目录结构：

| include | src | conf | log | htdocs    |
| ---- | ---- | ---- | ---- |-----------|
| 头文件 | 源文件 | 配置文件 | 日志文件 | 前端静态界面文件夹 |

### 1. 构建方法

```shell
mkdir build
cd build
cmake ../
make
```

## 二. WebServer总体流程

* 收到消息请求之后，将所有请求内容读取出来。封装成一个request对象。

* 解析request对象，最终处理，返回一个response对象。

* 将response对象发送回去。

(编程全部完成后, 画个流程图补在这里)

### 1. 日志模块

日志模块，实现日志功能。

已有功能：

* 日志分级。
* 自定义日志格式。（时间戳，线程ID，文件，行号，日志级别）
* 自定义输出位置。
* 支持流式日志。

工作流程：

1. 初始化LogFormatter，LogAppender, Logger。

2. 其中LogFormatter和LogEvent会完成日志格式的解析。将每一个关注的日志项都封装了一个类。通过在构造LogFormatter时的参数，决定添加哪些项。重点关注该函数的init()

3. 通过宏定义提供**流式风格**和**格式化风格**的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，通过LogEvent和对应Logger生成一个LogEventWrap对象。

4. 宏执行结束后，LogEventWrap对象析构，在析构函数里调用`Logger`的log方法将日志事件进行输出(打印)。

主要的几个类:

* LogEvent

  把写日志当作一个事件，记录日志现场信息。目前包括日志内容 ，日志器名称，日志级别，文件名和行号，程序运行时间，线程ID，UTC时间戳，线程名称等信息。

* LogFormatter

  日志格式器，用于格式化一个日志事件，将其转化成一串字符串。

* LogAppender

  日志输出器，用于输出一个日志事件。这是一个虚基类。 目前只有两个具体实现，比如往输出到cmd的StdoutLogAppender，以及输出到文件的FileLogAppender。

* Logger

  日志器，用于输出日志。这个类是**直接与用户进行交互的类**，提供一些方法用于输出日志事件。

* LogManager

  日志器管理类，单例模式，用于统一管理全部的日志器，提供getLogger()方法用于创建/获取日志器。内部维护一个名称到日志器的map，当获取的日志器存在时，直接返回对应的日志器指针，否则创建对应的日志器并返回。

改进点：format的init函数最好重新写一下，代码晦涩难懂，不好维护。

### 2. 配置模块

简单来说，就是服务器启动时读取相应配置文件。按照配置文件的设置启动，初始化。

已有功能：

* 定义即可使用。
* yaml文件支持多级配置项。如`tcp.connect.timeout`。
* 可以对于配置项注册回调函数，如果配置项的值变化，就会调用回调函数。（如port变化，就需要重新用新的port去listen）

待完善：

* 更新配置值时，检测值是否合法。(不完善，目前只是判断类型是否正确，无法判断值的范围是否正确)
* 动态变更配置文件，且使得运行中的程序做出相应改变。（考虑定时load配置文件，修改配置）

#### 2.1 约定大于配置

* [约定大于配置](https://zh.wikipedia.org/wiki/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE):
程序所依赖的配置项都有一个**公认的名字**和默认值，也就是约定。对于这些具有公认约定的配置，就不需要程序员在程序跑起来之前，一项一项去设置了。

* 约定优于配置的方式可以减少程序员做决定的数量，获得简单的好处，同时兼顾灵活性。

* **在代码上**，约定优于配置的思路体现为所有的配置项在定义时都带一个的默认值。在程序中定义过的配置才是合法配置。

#### 2.2 具体实现

配置文件是yaml格式，需要`yaml-cpp`库的支持。

ConfigItemBase基类有两个虚函数，toString和fromString。这两个函数的实现需要借助一些类型转化，毕竟C++标准库只提供了一部分类型和std::string的相互转换，像vector，map，set，自定义类型到string之间的转换就没有。需要自己实现。

然后实现一个ConfigManager类管理所有的配置项。主要提供两个接口loadFromYaml和loadFromCmd，用来从yaml配置文件和cmd参数中加载配置。读取yaml文件实际工作是由yaml-cpp库完成的。

通过ConfigManager对象管理配置时，**一定要先调用lookup接口，并且是有默认参数的接口**。后续读取配置文件只会读取通过lookup默认设置过的配置。其它配置项会被当成非法配置项。

程序中必须有这个配置，配置文件中写这个配置才有效。否则该配置非法。

### 3. 多线程模块

#### 3.1 Thread封装

由于std线程库的信号量，是在C++20才引入，所以还是使用POSIX线程库算了。POSIX都是一些函数接口, 于是想实现一个std::thread的Thread类。

1. 使用POSIX线程库封装一个类似std::thread的Thread类。实现返回**当前线程名，当前线程ID**的接口。
2. 构造时可以设置线程名，debug时还是比较有用的。实现返回Thread对象的线程id，线程名。
3. 封装POSIX的一些信号量，条件变量，互斥量之类的。总不能使用std提供的线程同步机制，去同步POSIX线程吧。（std::thread和POSIX混用，太概率会出问题）

#### 3.2 ThreadPool

线程池对象。通过上面封装好的Thread和Semaphore类实现。

1. 构造时固定线程数。
2. 任务可以是任何可调用对象，使用互斥量保护任务队列的线程安全。
3. 消费者生产者模式，使用信号量通知新任务的到来。（std标准文档也说信号量性能比条件变量好，那就用信号量）
4. 通过std::future返回任务结果。
5. 优雅关闭, 析构时不允许增加新的任务，同时保证剩余任务全部执行完毕。

### 4. HTTP请求解析

专门用来解析http请求。

## 改进点

1. 定时器重写。
2. main函数，需要改进整个程序工作流程。
3. 对于http协议解析，还需要重新设计重写。
4. useEpoll这两个文件已经删除，封装的毫无意义。重新想想怎么封装吧。如一个抽象类，提供io多路复用的功能，但内部可能使用poll，epoll等实现。
