
# WebServer

练手写的http服务器，慢慢完善修改。

## 一. 编译环境

系统：Ubuntu20.04

工具链：g++ 9.4.0；gdb 9.2；make 4.2.1；cmake 3.16.3

第三方依赖库：

1. [yaml-cpp](https://github.com/jbeder/yaml-cpp)

2. boost 1.71

目录结构：

| include | src | conf | log | htdocs    |
| ---- | ---- | ---- | ---- |-----------|
| 头文件 | 源文件 | 配置文件 | 日志文件 | 前端静态界面文件夹 |

### 1. 构建方法

```shell
mkdir build
cd build
cmake ../
make
```

## 二. WebServer总体流程

* 收到消息请求之后，将所有请求内容读取出来。封装成一个request对象。

* 解析request对象，最终处理，返回一个response对象。

* 将response对象发送回去。

(编程全部完成后, 画个流程图补在这里)

### 1. 日志模块

日志模块，实现日志功能。

已有功能：

* 日志分级。
* 自定义日志格式。（时间戳，线程ID，文件，行号，日志级别）
* 自定义输出位置。
* 支持流式日志。

工作流程：

1. 初始化LogFormatter，LogAppender, Logger。

2. 其中LogFormatter和LogEvent会完成日志格式的解析。将每一个关注的日志项都封装了一个类。通过在构造LogFormatter时的参数，决定添加哪些项。重点关注该函数的init()

3. 通过宏定义提供**流式风格**和**格式化风格**的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，通过LogEvent和对应Logger生成一个LogEventWrap对象。

4. 宏执行结束后，LogEventWrap对象析构，在析构函数里调用`Logger`的log方法将日志事件进行输出(打印)。

主要的几个类:

* LogEvent

  把写日志当作一个事件，记录日志现场信息。目前包括日志内容 ，日志器名称，日志级别，文件名和行号，程序运行时间，线程ID，UTC时间戳，线程名称等信息。

* LogFormatter

  日志格式器，用于格式化一个日志事件，将其转化成一串字符串。

* LogAppender

  日志输出器，用于输出一个日志事件。这是一个虚基类。 目前只有两个具体实现，比如往输出到cmd的StdoutLogAppender，以及输出到文件的FileLogAppender。

* Logger

  日志器，用于输出日志。这个类是**直接与用户进行交互的类**，提供一些方法用于输出日志事件。

* LogManager

  日志器管理类，单例模式，用于统一管理全部的日志器，提供getLogger()方法用于创建/获取日志器。内部维护一个名称到日志器的map，当获取的日志器存在时，直接返回对应的日志器指针，否则创建对应的日志器并返回。

改进点：format的init函数最好重新写一下，代码晦涩难懂，不好维护。

### 2. 配置模块

简单来说，就是服务器启动时读取相应配置文件。按照配置文件的设置启动，初始化。

配置包含：

1. 名称，对应一个字符串，必须唯一，不能与其他配置项产生冲突。

2. 类型，可以是基本类型，但也应该支持复杂类型和自定义类型。

3. 值。配置对应的值，通常还会有默认值。

4. 配置变更通知，一旦用户更新了配置值，那么应该通知所有使用了这项配置的代码，以便于进行一些具体的操作，比如重新打开文件，重新起监听端口等。也就是**支持动态配置**。

5. 校验方法，更新配置时会调用校验方法进行校验，以保证用户不会给配置项设置一个非法的值。

#### 2.1 约定大于配置

[约定大于配置](https://zh.wikipedia.org/wiki/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE):
程序所依赖的配置项都有一个**公认的名字**和默认值，也就是约定。对于这些具有公认约定的配置，就不需要程序员在程序跑起来之前，一项一项去设置了。

约定优于配置的方式可以减少程序员做决定的数量，获得简单的好处，同时兼顾灵活性。

**在代码上**，约定优于配置的思路体现为所有的配置项在定义时都带一个的默认值。

已有功能：

* 定义即可使用。
* 多级配置项。如`tcp.connect.timeout`。
* 动态变更配置值，生效。（怎么知道配置被改变的？ 定时重新调用一次loadFromYaml接口？）

配置文件时yaml格式，需要`yaml-cpp`库的支持。

ConfigItemBase基类有两个虚函数，toString和fromString。这两个函数的实现需要借助一些类型转化，毕竟C++标准库只提供了一部分类型和std::string的相互转换，像vector，map，set，自定义类型之类到string之间的转换就没有。
所以需要实现，也不是std::string，而是yaml::string类型（好像都是一样的）。

然后实现一个ConfigManager类管理所有的配置项。主要提供两个接口loadFromYaml和loadFromCmd，用来从yaml配置文件和cmd参数中加载配置。读取yaml文件实际工作是由yaml-cpp库完成的。

### 3. 多线程模块

#### 3.1 Thread封装

由于std线程库的信号量，是在C++20才引入，所以还是使用POSIX线程库算了。POSIX都是一些函数接口, 于是想实现一个std::thread的Thread类。

1. 使用POSIX线程库封装一个类似std::thread的Thread类。实现返回**当前线程名，当前线程ID**的接口。
2. 构造时可以设置线程名，debug时还是比较有用的。实现返回Thread对象的线程id，线程名。
3. 封装POSIX的一些信号量，条件变量，互斥量之类的。总不能使用std提供的线程同步机制，去同步POSIX线程吧。（std::thread和POSIX混用，太概率会出问题）

#### 3.2 ThreadPool

线程池对象。通过上面封装好的Thread和Semaphore类实现。

1. 构造时固定线程数。
2. 任务可以是任何可调用对象，使用互斥量保护任务队列的线程安全。
3. 消费者生产者模式，使用信号量通知新任务的到来。（std标准文档也说信号量性能比条件变量好，那就用信号量）
4. 通过std::future返回任务结果。
5. 优雅关闭, 析构时不允许增加新的任务，同时保证剩余任务全部执行完毕。

### 4. HTTP请求解析

专门用来解析http请求。

## 改进点

1. 对于main函数，需要改进整个流程。
2. 对于http协议解析，还需要重新设计重写。
3. useEpoll这两个文件已经删除，封装的毫无意义。重新想想怎么封装吧。如一个抽象类，提供io多路复用的功能，但内部可能使用poll，epoll等实现。
4. 重写定时器, 定时器新增定时任务时，要可以传入参数，且可以有返回值。
