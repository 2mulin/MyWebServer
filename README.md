# WebServer
### 编译环境：
CentOS7.7、g++4.8.5、gdb 7.9、cmake2.8.12.2、make3.82

* <p>使用了epoll边缘触发 + 非阻塞IO + EPOLLONESHOT
  EPOLLONESHOT的效果是设置的fd只会触发一次,是为了保证同一个client_fd的请求同时只会被一个线程处理.
  1. (因为客户端fd可能会相隔没多久发送多个请求, 如果线程正在处理请求,这时同一个客户端又来了另一个请求,
  而其他线程又是空闲的话, 那么其他线程可能也会去处理这个fd)
  2. 删除不安全
  请求刚被执行完, 正要被删除, 但是epoll_wait被触发, 还是同一个fd, 那就会再添加一次任务,
  但是不会马上执行任务, 如果包含这个fd的httpData被删除时, 他又去执行任务, 那么 
  最终访问httpData执行任务的时候, 就会出现意料之外的错误(段错误或者其它的)
  <p/>
* 使用了一个固定线程数的线程池(单例模式)
* 使用锁的地方
  * 实现一个连接队列, 处理客户端请求, 及返回响应 
  * 实现一个任务队列, 线程池处理任务
* 状态机解析HTTP报文, 支持get、post请求，支持长短连接


### 改进点: 
请求队列应该是各台服务器之间预设计好的, 静态的, 永久的TCP连接
<高性能服务器编程>原话, 所以我的服务器requestData队列可以换一个实现方式.

 * TCP连接的关闭过程有两种，一种是优雅关闭（graceful close），一种是强制关闭（hard close或abortive close）。
 * 所谓优雅关闭是指，如果发送缓存中还有数据未发出则其发出去，并且收到所有数据的ACK之后，发送FIN包，开始关闭过程。
 * 而强制关闭是指如果缓存中还有数据，则这些数据都将被丢弃，然后发送RST包，直接重置TCP连接。

### 心路历程
这个项目最开始做的时候, 是大四上学期的时候, 那时候出生牛图不怕虎,觉得自己很厉害,拿着别人的项目模仿, 这不做不知道
一做就发现, 这Linux系统调用我是一窍不通, 买了本TLPI, 边看边做, 也只能做点简单的socket编程, 做到后面什么EPOLL,非阻塞IO
听都没听过. 于是就沉下心来看书, 学习Linux系统编程去了, 这些就没继续写了. 

直到现在, 我是知道, 大部分的Linux的系统调用我都知道了,阻塞IO,非阻塞IO,Reactor,线程池,这些概念都有了.重新拿过来做
发现变得简单了一些. 但是我仍然有疑惑的地方.

1: 处理非活跃连接
处理非活跃链接的时候, 作者的想法是, timer和httpdata各自有成员变量指针互指, 再将timer*放在最小堆中,线程池执行任务时
timer和httpdata指针各自指向nullptr, 等到任务执行完之后, 再给httpdata绑定新的timer,原来timer被检测到指向httpdata
的指针为空时就会被删除.

这里比较难理解的就是为什么要这么做, 我的理解就是说, httpdata会被工作线程占有, 执行请求的解析.发送响应等
如果timer不和httpdata解开的话, 短连接我可以直接删除,但是长连接会出问题. 我需要更新计时器到期时间并且调整
计时器在最小堆中的位置, 这非常困难, 并且时间复杂度都是O(n).不仅如此, 最难的是要考虑线程安全的问题,每个线程都有可能
修改自己的timer的位置, 那就需要对queue的操作上锁, 那么并发就会下降. 即使上锁, 保证安全也很难, 涉及到主线程add和de,工作线程
的修改位置操作, 三个操作都要保证安全. 

我也看了其它的处理非活跃链接的方法, 比如游双高性能服务器编程书籍上代码,使用双向链表. 但是不知道为什么我的双向链表就是不对
老是段错误. 还得研究研究.