
# WebServer

练手写的http服务器，慢慢完善修改。

## 一. 编译环境

系统：Ubuntu20.04

工具链：g++ 9.4.0；gdb 9.2；make 4.2.1；cmake 3.16.3

第三方依赖库：

1. [yaml-cpp](https://github.com/jbeder/yaml-cpp)

2. boost 1.71

目录结构：

| include | src | conf | log | htdocs    |
| ---- | ---- | ---- | ---- |-----------|
| 头文件 | 源文件 | 配置文件 | 日志文件 | 前端静态界面文件夹 |

### 1. 构建方法

```shell
mkdir build
cd build
cmake ../
make
```

## 二. WebServer总体流程

* 收到消息请求之后，将所有请求内容读取出来。封装成一个request对象。

* 解析request对象，最终处理，返回一个response对象。

* 将response对象发送回去。

(编程全部完成后, 画个流程图补在这里)

### 1. 日志模块

日志模块，实现日志功能。

已有功能：

* 日志分级。
* 自定义日志格式。（时间戳，线程ID，文件，行号，日志级别）
* 自定义输出位置。
* 支持流式日志。

工作流程：

1. 初始化LogFormatter，LogAppender, Logger。

2. 其中LogFormatter和LogEvent会完成日志格式的解析。将每一个关注的日志项都封装了一个类。通过在构造LogFormatter时的参数，决定添加哪些项。重点关注该函数的init()

3. 通过宏定义提供**流式风格**和**格式化风格**的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，通过LogEvent和对应Logger生成一个LogEventWrap对象。

4. 宏执行结束后，LogEventWrap对象析构，在析构函数里调用`Logger`的log方法将日志事件进行输出(打印)。

主要的几个类:

* LogEvent

  把写日志当作一个事件，记录日志现场信息。目前包括日志内容 ，日志器名称，日志级别，文件名和行号，程序运行时间，线程ID，UTC时间戳，线程名称等信息。

* LogFormatter

  日志格式器，用于格式化一个日志事件，将其转化成一串字符串。

* LogAppender

  日志输出器，用于输出一个日志事件。这是一个虚基类。 目前只有两个具体实现，比如往输出到cmd的StdoutLogAppender，以及输出到文件的FileLogAppender。

* Logger

  日志器，用于输出日志。这个类是**直接与用户进行交互的类**，提供一些方法用于输出日志事件。

* LogManager

  日志器管理类，单例模式，用于统一管理全部的日志器，提供getLogger()方法用于创建/获取日志器。内部维护一个名称到日志器的map，当获取的日志器存在时，直接返回对应的日志器指针，否则创建对应的日志器并返回。

改进点：format的init函数最好重新写一下，代码晦涩难懂，不好维护。

### 2. 配置模块

简单来说，就是服务器启动时读取相应配置文件。按照配置文件的设置启动，初始化。

已有功能：

* 定义即可使用。
* yaml文件支持多级配置项。如`tcp.connect.timeout`。
* 可以对于配置项注册回调函数，如果配置项的值变化，就会调用回调函数。（如port变化，就需要重新用新的port去listen）

待完善：

* 更新配置值时，检测值是否合法。(不完善，目前只是判断类型是否正确，无法判断值的范围是否正确)
* 动态变更配置文件，且使得运行中的程序做出相应改变。（考虑定时load配置文件，修改配置）

#### 2.1 约定大于配置

* [约定大于配置](https://zh.wikipedia.org/wiki/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE):
程序所依赖的配置项都有一个**公认的名字**和默认值，也就是约定。对于这些具有公认约定的配置，就不需要程序员在程序跑起来之前，一项一项去设置了。

* 约定优于配置的方式可以减少程序员做决定的数量，获得简单的好处，同时兼顾灵活性。

* **在代码上**，约定优于配置的思路体现为所有的配置项在定义时都带一个的默认值。在程序中定义过的配置才是合法配置。

#### 2.2 具体实现

配置文件是yaml格式，需要`yaml-cpp`库的支持。

ConfigItemBase基类有两个虚函数，toString和fromString。这两个函数的实现需要借助一些类型转化，毕竟C++标准库只提供了一部分类型和std::string的相互转换，像vector，map，set，自定义类型到string之间的转换就没有。需要自己实现。

然后实现一个ConfigManager类管理所有的配置项。主要提供两个接口loadFromYaml和loadFromCmd，用来从yaml配置文件和cmd参数中加载配置。读取yaml文件实际工作是由yaml-cpp库完成的。

通过ConfigManager对象管理配置时，**一定要先调用lookup接口，并且是有默认参数的接口**。后续读取配置文件只会读取通过lookup默认设置过的配置。其它配置项会被当成非法配置项。

程序中必须有这个配置，配置文件中写这个配置才有效。否则该配置非法。

### 3. 多线程模块

#### 3.1 Thread封装

由于std线程库的信号量，是在C++20才引入，所以还是使用POSIX线程库算了。POSIX都是一些函数接口, 于是想实现一个std::thread的Thread类。

1. 使用POSIX线程库封装一个类似std::thread的Thread类。实现返回**当前线程名，当前线程ID**的接口。
2. 构造时可以设置线程名，debug时还是比较有用的。实现返回Thread对象的线程id，线程名。
3. 封装POSIX的一些信号量，条件变量，互斥量之类的。总不能使用std提供的线程同步机制，去同步POSIX线程吧。（std::thread和POSIX混用，太概率会出问题）

#### 3.2 ThreadPool

线程池对象。通过上面封装好的Thread和Semaphore类实现。

1. 构造时固定线程数。
2. 任务可以是任何可调用对象，使用互斥量保护任务队列的线程安全。
3. 消费者生产者模式，使用信号量通知新任务的到来。（std标准文档也说信号量性能比条件变量好，那就用信号量）
4. 通过std::future返回任务结果。
5. 优雅关闭, 析构时不允许增加新的任务，同时保证剩余任务全部执行完毕。

### 4. 定时器模块

定时器的作用就是，可以设置一个函数定时执行。

#### 4.1 数据结构选择

首先选择数据结构，比较常用的就是双向有序链表，最小堆（时间堆），时间轮。其中双向有序列表和最小堆都是按照触发时间顺序将任务排好序。
当然，堆是**堆序**，不是完全有序，但是不影响任务执行顺序。

时间轮比较复杂。后续再说

目前这里选择的是时间堆。使用`std::priority_queue`。

#### 4.2 实现计时

如何实现计时？也就是判断时间到了，然后通知去执行任务。

##### 4.2.1 分析

1. 最简单的想法，while循环不断判断获取时间，然后判断当前时间是否需要执行任务。为了不影响其它逻辑，单独开一个线程进行这个while循环。

2. 显然方法1不好，它是忙等，将会完整的占用一个CPU逻辑核。解决也很简单，使用sleep函数族。sleep是将当前线程挂起，直达经过设定的时间，或未被忽视的信号到达。才会被唤醒。
可以计算出下一个要执行的任务据当前时间的间隔，然后sleep（`sleep`，`usleep`，`nanosleep`等）这么久。

3. 例如Linux提供的定时器相关系统调用：`alarm`，`setitimer`。但是它们到了规定时间后，发送一个`SIGALRM`信号，信号处理函数去负责执行相应任务。如果第一个`alarm`设置之后，来了一个马上要执行的新任务，可以再次`alarm`，这样之前的alarm就会失效。
按照最新设置的时间发送信号。`alarm`，**`setitimer`的问题在于`SIGALRM`信号不可靠（不排队）。而且发送信号，处理信号是对于整个进程而言的，不是线程，可能对其它线程造成不好的影响。**

4. 由于信号的原因，使用`alarm`，`settimer`实现计时并不是很好的选择。计时功能除了上述函数之外，还有一种就是IO多路复用的系统调用，比如说poll，epoll之类的，
它们都提供了`timeout`参数，如果到达这个时间，监控的IO事件没有就绪，那么就会返回。

5. 可能是由于epoll(2.5.44)被大家用来计时，Linux在2.6.25内核版本之后就专门提供了一种`timerfd`，该fd的可读事件表示定时器到期了。

##### 4.2.2 问题

计时完成后，不管使用上述哪种方式实现计时，最后都需要一种通知机制，来打断当前计时器的休眠状态。可以想象这样一种场景：

当前有2个定时任务，分别是300s，500s后执行。现在定时器执行完成当前任务，发现下一个任务是300s之后，于是sleep 300s或设置epoll timeout参数为300s等等。
**10s之后，突然插入一个新任务，该任务需要20s之后执行。**

**此时sleep 300s计时必须被打断，重新设置计时（超时）时间**。

#### 4.3 具体实现（思路还未实现）

1. 单独开一个线程专门用来计时。使用`epoll`和`timerfd`实现。
2. 解决4.2.2提出的问题，实在不行就是信号量睡眠，epoll监听的timerfd触发之后，post信号量，唤醒计时器。
3. （优化）定时器任务合并。同一个时间点的任务合并为一个计时任务，减少内存开销。

### 5. HTTP请求解析

专门用来解析http请求。

## 改进点

1. 完善定时器。
2. main函数，需要改进整个程序工作流程。
3. 对于http协议解析，还需要重新设计重写。
4. useEpoll这两个文件已经删除，封装的毫无意义。重新想想怎么封装吧。如一个抽象类，提供io多路复用的功能，但内部可能使用poll，epoll等实现。
