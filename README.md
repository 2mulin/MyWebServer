# WebServer
### 编译环境：
CentOS7.7、g++4.8.5、gdb 7.9、cmake2.8.12.2、make3.82

* 使用了epoll边缘触发 + 非阻塞IO + EPOLLONESHOT
  EPOLLONESHOT的效果是设置的fd只会被触发一次. 是为了保证同一个client_fd的请求同时只会被一个线程处理.
  1. 多个线程处理同一个httpdata 
     客户端可能会连续发送两个请求,如果线程正在处理第一个请求,这时客户端又来了第二个请求,不设置EPOLLONESHOT就会再次触发而其他线程又是空闲的话, 
     那么其他线程可能也会去处理这个fd对应的httpdata,两个线程访问同一个httpdata,当然不行.
  2. 删除不安全
     fd请求刚被执行完,正在主线程中被删除(还没有从EPOLL实例删除), 他又触发了, 那就会再添加一次任务, 但是又不会马上执行任务(工作线程繁忙).
     之后这个fd的httpData被删除后, 工作线程又去执行任务, 那么执行任务时访问的httpData数据是空的, 就会出现意料之外的错误(段错误或者其它的
     
所以在任务没有执行完之前, httpdata要被一个工作线程独占, 要防止其他线程修改它.
     
* 使用了一个固定线程数的线程池(单例模式)
* 使用锁的地方
  * 实现一个连接队列, 处理客户端请求, 及返回响应 
  * 实现一个任务队列, 线程池处理任务
* 状态机解析HTTP报文, 支持get、post请求，支持长短连接

### 心路历程
这个项目最开始做的时候, 是大四上学期的时候, 那时候出生牛图不怕虎,觉得自己很厉害,拿着别人的项目模仿, 这不做不知道
一做就发现, 这Linux系统调用没几个看得懂的, 买了本TLPI, 边学边做, 也只能做点简单的socket编程, 做到后面什么EPOLL,非阻塞IO
听都没听过. 于是就沉下心来看书, 学习Linux系统编程去了, 这些就没继续写了. 

直到现在, 大部分的Linux的系统调用我都了解了,阻塞IO,非阻塞IO,Reactor,线程池,这些概念都有了.重新拿过来做
发现变得简单了一些. 但是我仍然有疑惑的地方.

### 难点
1: 处理非活跃连接
处理非活跃链接的时候, 作者的想法是, timer和httpdata各自有成员变量指针互指, 再将timer*放在最小堆中,线程池执行任务时
timer和httpdata指针各自指向nullptr, 等到任务执行完之后, 再给httpdata绑定新的timer,原来timer被检测到指向httpdata
的指针为空时就会被删除.

这里比较难理解的就是为什么要这么做, 我的理解就是说, httpdata会被工作线程占有, 执行请求的解析.发送响应等
如果timer不和httpdata解开的话, 短连接我可以直接删除,但是长连接会出问题. 我需要更新计时器到期时间并且调整
计时器在最小堆中的位置, 这非常困难, 并且时间复杂度都是O(n).不仅如此, 最难的是要考虑线程安全的问题,每个线程都有可能
修改自己的timer的位置, 那就需要对queue的操作上锁, 那么并发就会下降. 即使上锁, 保证安全也很难, 涉及到主线程add和de,工作线程
的修改位置操作, 三个操作都要保证安全.